#!/bin/bash

# Basic help function
help()
{
  cat <<EOF
batman, a battery management program originally intended for Droidian

Usage: batman
EOF
  exit 0
}

# Bumped at every commit
version()
{
   echo "0.37"
   exit 0
}

# First check if user is asking for help or version if not move on.
case "$1" in
  -h|-\?|--help)
    help
    ;;
  -v|--version)
    version
    ;;
esac

# CORE_FIRST will read cpuinfo and get the first cpu core number at boot. (we know its 0 but just in case to be 100% safe)
# CORE_LAST will read cpuinfo and get the last cpu core number at boot.
# UIDS will list users from /run/user to later use with wlr-randr.
# DEFAULT_GOVERNOR stores the default cpu governor used by the device.
# AVUSER will get the number of active user sessions. It's used later on to make sure there is only one active user with a session.
# AVPOL will check for the amount of cpu policy groups. It's used later on to disable offlining on devices with a single group.
# FIRSTPOL will get the first policy group. (this group stores LITTLE cores)
# FIRSTPOLCORE will get the first cpu core of policy group one.
# LASTPOLCORE will get the last cpu core of policy group one.
# UPTIME is just uptime of the system in minutes.
CORE_FIRST=$(awk '$1 == "processor" {print $3; exit}' /proc/cpuinfo)
CORE_LAST=$(awk '$1 == "processor" {print $3}' /proc/cpuinfo | tail -1)
UIDS=$(ls /run/user | head -1)

# x86 cpus have powersave and performance governors, check architecture and set the governor accordingly.
if [ "$(uname -m)" = "x86_64" ] || [ "$(uname -m)" = "i686" ]; then

   if grep "performance" /sys/devices/system/cpu/cpu$CORE_FIRST/cpufreq/scaling_available_governors &> /dev/null; then
      DEFAULT_GOVERNOR="performance"
   else
      echo "can't find the right governor. exiting"
      exit 0
   fi

else
   DEFAULT_GOVERNOR=$(</sys/devices/system/cpu/cpu$CORE_FIRST/cpufreq/scaling_governor)
fi

AVUSER=$(ls /run/user | wc -l)
AVPOL=$(ls /sys/devices/system/cpu/cpufreq | grep -c policy)
FIRSTPOL=$(ls /sys/devices/system/cpu/cpufreq | grep policy | head -1)
FIRSTPOLCORE=$(cut -c1 - < /sys/devices/system/cpu/cpufreq/$FIRSTPOL/related_cpus)
LASTPOLCORE=$(awk '{for(i=NF;i>=1;i--) printf("%s ", $i)}' /sys/devices/system/cpu/cpufreq/$FIRSTPOL/related_cpus | cut -c1 -)
UPTIME=$(awk '{print int($1)/60}' /proc/uptime | cut -f 1 -d .)

# Make sure the required directory exists.
if [ ! -d /var/lib/batman/ ]; then
   mkdir -p /var/lib/batman/
fi

# Parse our config file.
if [ -f /var/lib/batman/config ]; then
   . /var/lib/batman/config
else
   echo "config file does not exist. using default values"
fi

# Check if there are any policies available.
if [[ "$AVPOL" == "0" ]]; then
   echo "no cpu policies available. exiting"
   exit 0
fi

# Check if powersave governor is available.
if grep powersave /sys/devices/system/cpu/cpufreq/$FIRSTPOL/scaling_available_governors &> /dev/null; then
   true
else
   echo "powersave is not a governor on this system. exiting"
   exit 0
fi

# We depend on upower for charging status.
if ! [[ $(which upower) ]]; then
   echo "upower is not available. exiting"
   exit 0
fi

# Make sure wlr-randr is installed on the system.
# If it was check if system is using a wlroots based desktop environment.
if [[ $(which wlr-randr) ]]; then
   XDG_RUNTIME_DIR=/run/user/$UIDS/ wlr-randr &> /var/lib/batman/wlr-randr

   if grep "compositor doesn't support" /var/lib/batman/wlr-randr &> /dev/null; then
      WLROOTS=false
   else
      WLROOTS=true
   fi

else
   echo "wlr-randr does not exist."
   exit 0
fi

# Check if Phosh/sxmo has started. if not wait a bit and retry.
if [ "$WLROOTS" == "true" ]; then
   while [[ true ]]
   do
      XDG_RUNTIME_DIR=/run/user/$UIDS/ wlr-randr &> /dev/null

      if [ $? -eq 0 ]; then
         # If the exit status is 0, break out of the loop
         break
      else
         # If the exit status is not 0, wait for some time and try again
         sleep 1
      fi

   done
fi

# Check if system is using KDE Plasma.
if [ "$WLROOTS" == "false" ] && [[ $(which kscreen-doctor) ]]; then

   if XDG_SESSION_TYPE=wayland XDG_RUNTIME_DIR=/run/user/$UIDS/ kscreen-doctor -o | grep Output &> /dev/null; then
      KDE=true
   else
      KDE=false
   fi

else
   KDE=false
fi

# If none of the supported compositors are used then exit.
if [ "$KDE" == "false" ] && [ "$WLROOTS" == "false" ]; then
   echo "Display server not supported. exiting"
   exit 0
fi

# Use our AVUSER variable to make sure only one active user session exists.
if [[ "$AVUSER" -gt "1" ]]; then
   echo "more than one user active. exiting"
   exit 0
fi

# Make sure that our OFFLINE variable is set from the config file if not use default value.
if [ -z "$OFFLINE" ]; then
   OFFLINE=true
fi

# Use our AVPOL variable to make sure our device has more than one policy groups.
# If there was only one set the variable to not offline any cpu cores.
if [[ "$AVPOL" -eq "1" ]] || [[ "$(uname -m)" = "x86_64" ]] || [[ "$(uname -m)" = "i686" ]]; then
   OFFLINE=false
fi

# Make sure that our POWERSAVE variable is set from the config file if not use default value.
if [ -z "$POWERSAVE" ]; then
   POWERSAVE=true
fi

# Make sure that our MAX_CPU_USAGE variable is set from the config file if not use default value.
if [ -z "$MAX_CPU_USAGE" ]; then
   MAX_CPU_USAGE=60
fi

# Make sure that our CHARGESAVE variable is set from the config file if not use default value.
if [ -z "$CHARGESAVE" ]; then
   CHARGESAVE=false
fi

# Make sure that our GPUSAVE variable is set from the config file if not use default value.
if [ -z "$GPUSAVE" ]; then
   GPUSAVE=true
fi

# Make sure that our BUSSAVE variable is set from the config file if not use default value.
if [ -z "$BUSSAVE" ]; then
   BUSSAVE=true
fi

# Check if we can find any GPU profile in devfreq.
if [ -d /sys/class/devfreq/ ]; then
   DEVFREQ_GPU_PATH=$(find /sys/class/devfreq -name "*.gpu" -print -quit)
fi

# Check if GPU governor file exists in different paths if not give up and disable GPU powersaving.
if [ -f /sys/class/kgsl/kgsl-3d0/devfreq/governor ]; then
   GPUSAVE=true
   DEFAULT_GPU_GOVERNOR=$(</sys/class/kgsl/kgsl-3d0/devfreq/governor)
   GPU_GOVERNOR_PATH="/sys/class/kgsl/kgsl-3d0/devfreq/governor"
elif [ -f /sys/class/kgsl/kgsl-3d0/governor ]; then
   GPUSAVE=true
   DEFAULT_GPU_GOVERNOR=$(</sys/class/kgsl/kgsl-3d0/governor)
   GPU_GOVERNOR_PATH="/sys/class/kgsl/kgsl-3d0/governor"
elif [ -f /sys/class/devfreq/1c00000.qcom,kgsl-3d0/governor ]; then
   GPUSAVE=true
   DEFAULT_GPU_GOVERNOR=$(</sys/class/devfreq/1c00000.qcom,kgsl-3d0/governor)
   GPU_GOVERNOR_PATH="/sys/class/devfreq/1c00000.qcom,kgsl-3d0/governor"
elif [ -f /sys/class/devfreq/ddr_devfreq/governor ]; then
   GPUSAVE=true
   DEFAULT_GPU_GOVERNOR=$(</sys/class/devfreq/ddr_devfreq/governor)
   GPU_GOVERNOR_PATH="/sys/class/devfreq/ddr_devfreq/governor"
elif [ -f /sys/class/devfreq/graphics/governor ]; then
   GPUSAVE=true
   DEFAULT_GPU_GOVERNOR=$(</sys/class/devfreq/graphics/governor)
   GPU_GOVERNOR_PATH="/sys/class/devfreq/graphics/governor"
elif [ -f /sys/kernel/gpu/gpu_governor ]; then
   GPUSAVE=true
   DEFAULT_GPU_GOVERNOR=$(</sys/kernel/gpu/gpu_governor)
   GPU_GOVERNOR_PATH="/sys/kernel/gpu/gpu_governor"
elif [ -f $DEVFREQ_GPU_PATH/governor ]; then
   GPUSAVE=true
   DEFAULT_GPU_GOVERNOR=$(<$DEVFREQ_GPU_PATH/governor)
   GPU_GOVERNOR_PATH="$DEVFREQ_GPU_PATH/governor"
else
   GPUSAVE=false
fi

# If powersave is not a governor in the GPU profile then disable this feature.
if [ $GPUSAVE == "true" ]; then

   if grep "powersave" $GPU_GOVERNOR_PATH &> /dev/null; then
      true
   else
      GPUSAVE=false
   fi

fi

# Check for bus governor nodes, if available then we'll powersave them too!
if [ "$BUSSAVE" == "true" ] && [ -d /sys/class/devfreq/ ]; then

   if [ -d /sys/class/devfreq/soc:qcom,cci/ ]; then
      CCI=true
      DEFAULT_CCI_GOVERNOR=$(</sys/class/devfreq/soc:qcom,cci/governor)
   fi

   if [ -d /sys/class/devfreq/soc:qcom,cpubw/ ]; then
      CPUBW=true
      DEFAULT_CPUBW_GOVERNOR=$(</sys/class/devfreq/soc:qcom,cpubw/governor)
   fi

   if [ -d /sys/class/devfreq/soc:qcom,gpubw/ ]; then
      GPUBW=true
      DEFAULT_GPUBW_GOVERNOR=$(</sys/class/devfreq/soc:qcom,gpubw/governor)
   fi

   if [ -d /sys/class/devfreq/soc:qcom,kgsl-busmon/ ]; then
      KGSL_BUSMON=true
      DEFAULT_KGSL_BUSMON_GOVERNOR=$(</sys/class/devfreq/soc:qcom,kgsl-busmon/governor)
   fi

   if [ -d /sys/class/devfreq/soc:qcom,mincpubw/ ]; then
      MINCPUBW=true
      DEFAULT_MINCPUBW_GOVERNOR=$(</sys/class/devfreq/soc:qcom,mincpubw/governor)
   fi

   if [ -d /sys/class/devfreq/soc:qcom,l3-cpu0/ ]; then
      L3CPU0=true
      DEFAULT_L3CPU0_GOVERNOR=$(</sys/class/devfreq/soc:qcom,l3cpu0/governor)
   fi

   if [ -d /sys/class/devfreq/soc:qcom,l3-cpu6/ ]; then
      L3CPU6=true
      DEFAULT_L3CPU6_GOVERNOR=$(</sys/class/devfreq/soc:qcom,l3cpu6/governor)
   fi

fi

# Copy default governor to a file to use it later on if the service gets restarted unexpectedly.
if [[ "$UPTIME" -le "1" ]]; then

   if [ "$DEFAULT_GOVERNOR" == "powersave" ]; then
      echo "bad starting governor. exiting"
      exit 0
   else
      echo $DEFAULT_GOVERNOR > /var/lib/batman/default_cpu_governor
   fi

   if [ "$GPUSAVE" == "true" ]; then
      echo $DEFAULT_GPU_GOVERNOR > /var/lib/batman/default_gpu_governor
   fi

   if [ "$CCI" == "true" ]; then
      echo $DEFAULT_CCI_GOVERNOR > /var/lib/batman/default_cci_governor
   fi

   if [ "$CPUBW" == "true" ]; then
      echo $DEFAULT_CPUBW_GOVERNOR > /var/lib/batman/default_cpubw_governor
   fi

   if [ "$GPUBW" == "true" ]; then
      echo $DEFAULT_GPUBW_GOVERNOR > /var/lib/batman/default_gpubw_governor
   fi

   if [ "$KGSL_BUSMON" == "true" ]; then
      echo $DEFAULT_KGSL_BUSMON_GOVERNOR > /var/lib/batman/default_kgsl_busmon_governor
   fi

   if [ "$MINCPUBW" == "true" ]; then
      echo $DEFAULT_MINCPUBW_GOVERNOR > /var/lib/batman/default_mincpubw_governor
   fi

   if [ "$L3CPU0" == "true" ]; then
      echo $DEFAULT_L3CPU0_GOVERNOR > /var/lib/batman/default_l3cpu0_governor
   fi

   if [ "$L3CPU6" == "true" ]; then
      echo $DEFAULT_L3CPU6_GOVERNOR > /var/lib/batman/default_l3cpu6_governor
   fi

fi

# In case of bad governor values choose the right value or exit if it fails to do so.
if [[ "$DEFAULT_GOVERNOR" == "powersave" ]]; then

   if [[ $(</var/lib/batman/default_cpu_governor)  == "powersave" ]]; then
      echo "bad starting governor. exiting"
      exit 0
   else
      DEFAULT_GOVERNOR=$(</var/lib/batman/default_cpu_governor)
   fi

fi

if [ "$GPUSAVE" == "true" ] && [ "$DEFAULT_GPU_GOVERNOR" == "powersave" ]; then

   if [[ $(</var/lib/batman/default_gpu_governor)  == "powersave" ]]; then
      echo "bad GPU governor. disabling GPU powersave"
      GPUSAVE=false
   else
      DEFAULT_GPU_GOVERNOR=$(</var/lib/batman/default_gpu_governor)
   fi

fi

if [ "$CCI" == "true" ] && [ "$DEFAULT_CCI_GOVERNOR" == "powersave" ]; then

   if [[ $(</var/lib/batman/default_cci_governor)  == "powersave" ]]; then
      echo "bad cci governor. disabling cci powersave"
      CCI=false
   else
      DEFAULT_CCI_GOVERNOR=$(</var/lib/batman/default_cci_governor)
   fi

fi

if [ "$CPUBW" == "true" ] && [ "$DEFAULT_CPUBW_GOVERNOR" == "powersave" ]; then

   if [[ $(</var/lib/batman/default_cpubw_governor)  == "powersave" ]]; then
      echo "bad cpubw governor. disabling cpubw powersave"
      CPUBW=false
   else
      DEFAULT_cpubw_GOVERNOR=$(</var/lib/batman/default_cpubw_governor)
   fi

fi

if [ "$GPUBW" == "true" ] && [ "$DEFAULT_GPUBW_GOVERNOR" == "powersave" ]; then

   if [[ $(</var/lib/batman/default_gpubw_governor)  == "powersave" ]]; then
      echo "bad gpubw governor. disabling gpubw powersave"
      GPUBW=false
   else
      DEFAULT_GPUBW_GOVERNOR=$(</var/lib/batman/default_gpubw_governor)
   fi

fi

if [ "$KGSL_BUSMON" == "true" ] && [ "$DEFAULT_KGSL_BUSMON_GOVERNOR" == "powersave" ]; then

   if [[ $(</var/lib/batman/default_kgsl_busmon_governor)  == "powersave" ]]; then
      echo "bad kgsl-busmon governor. disabling kgsl-busmon powersave"
      KGSL_BUSMON=false
   else
      DEFAULT_KGSL_BUSMON_GOVERNOR=$(</var/lib/batman/default_kgsl_busmon_governor)
   fi

fi

if [ "$MINICPUBW" == "true" ] && [ "$DEFAULT_MINICPUBW_GOVERNOR" == "powersave" ]; then

   if [[ $(</var/lib/batman/default_minicpubw_governor)  == "powersave" ]]; then
      echo "bad minicpubw governor. disabling minicpubw powersave"
      MINICPUBW=false
   else
      DEFAULT_MINICPUBW_GOVERNOR=$(</var/lib/batman/default_minicpubw_governor)
   fi

fi

if [ "$L3CPU0" == "true" ] && [ "$DEFAULT_L3CPU0_GOVERNOR" == "powersave" ]; then

   if [[ $(</var/lib/batman/default_l3cpu0_governor)  == "powersave" ]]; then
      echo "bad l3cpu0 governor. disabling l3cpu0 powersave"
      L3CPU0=false
   else
      DEFAULT_L3CPU0_GOVERNOR=$(</var/lib/batman/default_l3cpu0_governor)
   fi

fi

if [ "$L3CPU6" == "true" ] && [ "$DEFAULT_L3CPU6_GOVERNOR" == "powersave" ]; then

   if [[ $(</var/lib/batman/default_l3cpu6_governor)  == "powersave" ]]; then
      echo "bad l3cpu6 governor. disabling l3cpu6 powersave"
      L3CPU6=false
   else
      DEFAULT_L3CPU6_GOVERNOR=$(</var/lib/batman/default_l3cpu6_governor)
   fi

fi

# Function that sets the cpu governor to powersave.
function powersave() {
    for ((i=$CORE_FIRST;i<=$CORE_LAST; i++))
    do
        echo "powersave" > /sys/devices/system/cpu/cpu$i/cpufreq/scaling_governor
    done
}

# Function that sets the cpu governor to the default value.
function default() {
    for ((i=$CORE_FIRST;i<=$CORE_LAST; i++))
    do
         echo "$DEFAULT_GOVERNOR" > /sys/devices/system/cpu/cpu$i/cpufreq/scaling_governor
    done
}

# This function sets cpu cores in policy group one to offline.
function offline() {
    for ((i=$FIRSTPOLCORE;i<=$LASTPOLCORE; i++))
    do
         echo "0" > /sys/devices/system/cpu/cpu$i/online
    done
}

# This function sets cpu cores in policy group one to online.
function online() {
    for ((i=$FIRSTPOLCORE;i<=$LASTPOLCORE; i++))
    do
         echo "1" > /sys/devices/system/cpu/cpu$i/online
    done
}

# Check if GPUSAVE is enabled, if so enable use the right functions.
if [ "$GPUSAVE" == "true" ]; then

   function gpusave() {
       echo "powersave" > $GPU_GOVERNOR_PATH
   }

   function gpudefault() {
       echo "$DEFAULT_GPU_GOVERNOR" > $GPU_GOVERNOR_PATH
   }

else

   function gpusave() {
       true
   }

   function gpudefault() {
       true
   }

fi

# Check if BUSSAVE is enabled, if so enable use the right functions.
if [ "$BUSSAVE" == "true" ]; then

   function bussave() {
       if [ "$CCI" == "true" ]; then
          echo powersave > /sys/class/devfreq/soc:qcom,cci/governor
       fi

       if [ "$CPUBW" == "true" ]; then
          echo powersave > /sys/class/devfreq/soc:qcom,cpubw/governor
       fi

       if [ "$GPUBW" == "true" ]; then
          echo powersave > /sys/class/devfreq/soc:qcom,gpubw/governor
       fi

       if [ "$KGSL_BUSMON" == "true" ]; then
          echo powersave > /sys/class/devfreq/soc:qcom,kgsl-busmon/governor
       fi

       if [ "$MINCPUBW" == "true" ]; then
          echo powersave > /sys/class/devfreq/soc:qcom,mincpubw/governor
       fi

       if [ "$L3CPU0" == "true" ]; then
          echo powersave > /sys/class/devfreq/soc:qcom,l3cpu0/governor
       fi

       if [ "$L3CPU6" == "true" ]; then
          echo powersave > /sys/class/devfreq/soc:qcom,l3cpu6/governor
       fi
   }

   function busdefault() {
       if [ "$CCI" == "true" ]; then
          echo $DEFAULT_CCI_GOVERNOR > /sys/class/devfreq/soc:qcom,cci/governor
       fi

       if [ "$CPUBW" == "true" ]; then
          echo $DEFAULT_CPUBW_GOVERNOR > /sys/class/devfreq/soc:qcom,cpubw/governor
       fi

       if [ "$GPUBW" == "true" ]; then
          echo $DEFAULT_GPUBW_GOVERNOR > /sys/class/devfreq/soc:qcom,gpubw/governor
       fi

       if [ "$KGSL_BUSMON" == "true" ]; then
          echo $DEFAULT_KGSL_BUSMON_GOVERNOR > /sys/class/devfreq/soc:qcom,kgsl-busmon/governor
       fi

       if [ "$MINCPUBW" == "true" ]; then
          echo $DEFAULT_MINCPUBW_GOVERNOR > /sys/class/devfreq/soc:qcom,mincpubw/governor
       fi

       if [ "$L3CPU0" == "true" ]; then
          echo $DEFAULT_L3CPU0_GOVERNOR > /sys/class/devfreq/soc:qcom,l3cpu0/governor
       fi

       if [ "$L3CPU6" == "true" ]; then
          echo $DEFAULT_L3CPU6_GOVERNOR > /sys/class/devfreq/soc:qcom,l3cpu6/governor
       fi
   }

else

   function bussave() {
       true
   }

   function busdefault() {
       true
   }

fi

# This clears the screen status whether or not it is off.
echo "" > /var/lib/batman/screen

# Give ownership of /var/lib/batman to the user id available in /run/user.
chown $UIDS:$UIDS /var/lib/batman -R

while [[ true ]]
do
    # Save screen status of the last run to a variable so that we can use it later in our checks. (will be filled after the first run)
    SCREEN_OLD=$(</var/lib/batman/screen)
    # Get cpu usage from /proc/stat
    CPU_USAGE=$(awk '{u=$2+$4; t=$2+$4+$5; if (NR==1){u1=u; t1=t;} else print ($2+$4-u1) * 100 / (t-t1) ; }' <(grep 'cpu ' /proc/stat) <(sleep 0.2; grep 'cpu ' /proc/stat) | cut -d "." -f1)

    # Run the correct command to get screen status
    # Save screen status to a variable so that we can use it later in our checks.
    if [ "$WLROOTS" == "true" ]; then
       SCREEN=$(XDG_RUNTIME_DIR=/run/user/$UIDS/ wlr-randr | sed -n '/Enabled/s/^.\{11\}//p')
    elif [ "$KDE" == "true" ]; then
       DISPSTAT=$(XDG_SESSION_TYPE=wayland XDG_RUNTIME_DIR=/run/user/$UIDS kscreen-doctor -j | awk '/enabled/{print substr(reverse($0), 3, length($0)-24)}')

       if [ "$DISPSTAT" == "true" ]; then
          SCREEN="yes"
       else
          SCREEN="no"
       fi

    fi

    # if variable FIRSTPOLCORE=$(cut -c1 - < /sys/devices/system/cpu/cpufreq/$FIRSTPOL/related_cpus)
    if [ "$CHARGESAVE" == "true" ]; then
        CHARGE="discharging"
    else
        # Check if device is plugged into a power source.
        CHARGE=$(upower -d | awk '{if(/state/){if(!seen[$0]){seen[$0]=1;print substr($0,26);exit}}}')
    fi

    # Check if powersave should be enabled.
    if [ "$POWERSAVE" == "true" ]; then

       # if screen is off and device is not charging then device will be set into powersave
       if [ "$SCREEN_OLD" != "$SCREEN" ] && [ "$CHARGE" == "discharging" ] && [ "$SCREEN" == "no" ]; then
          powersave
          gpusave
          bussave
       # if device is charging or fully charged and still plugged into the wall then set everything back to default.
       elif [ "$SCREEN_OLD" != "$SCREEN" ] && [ "$CHARGE" == "charging" ] || [ "$CHARGE" == "fully-charged" ]; then
          default
          gpudefault
          busdefault
       # if screen is on (user using the device) set everything back to default.
       elif [ "$SCREEN" == "yes" ]; then
          default
          gpudefault
          busdefault
       fi

    fi

    # Save the current governor (check what has happened in the last run) so that if it is set to powersave we can use this info in our cpu offlining.
    CUR_GOVERNOR=$(</sys/devices/system/cpu/cpu0/cpufreq/scaling_governor)

    # Use our OFFLINE variable to see if this process should even be started.
    if [ "$OFFLINE" == "true" ]; then

       # if device is not plugged into a power source and screen is off and cpu usage is less than 40% (as an example user is not listening to some youtube video) then set cpu to offline.
       if [ "$SCREEN_OLD" != "$SCREEN" ] && [ "$CHARGE" == "discharging" ] && [ "$SCREEN" == "no" ] && [ "$CPU_USAGE" -le "$MAX_CPU_USAGE" ]; then
          offline
       # if screen or on or current governor is the same as default governor or cpu usage is higher than 40% set cpu cores to online. (all cases to not set cpu cores to offline accidentally)
       elif [ "$SCREEN" == "yes" ] || [ "$CUR_GOVERNOR" == "$DEFAULT_GOVERNOR" ] || [ "$CPU_USAGE" -gt "$MAX_CPU_USAGE" ]; then
          online
       # if device is powersave (which means device is sleeping) then set cpu cores to offline.
       elif [ "$SCREEN_OLD" == "$SCREEN" ] && [ "$CUR_GOVERNOR" == "powersave" ]; then
          offline
       fi

    fi

    # Put old status of screen into a file so that we can use it in the next run of this loop to lower cpu and memory usage later on.
    if [ "$SCREEN_OLD" != "$SCREEN" ]; then
       echo $SCREEN > /var/lib/batman/screen
    fi

    sleep 0.3

done
